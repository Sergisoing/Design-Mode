# Design-Mode
php设计模式学习

设计模式主要分为三类：
    创建型，结构型，行为型

一、创建型：
<ol>
    <li>工厂模式</li>
        <p>将对象的创建交给工厂来实现</p>
        <ul>
            <li>普通工厂</li>
                <img src="./img/SimpleFactory.jpg" height="500" width="660" alt="">
                <p>一般采用静态方法，给方法传递不同的参数生成不同的对象</p>
                <p>缺点在于：新增一个产品类的时候需要修改工厂方法</p>
            <li>工厂方法</li>
                <img src="./img/FactoryMethod.jpg" height="501" width="660" alt="">
                <p>与普通工厂不同的是为每一个产品创建了一个工厂，每个产品都对应这一个产品工厂</p>
            <li>抽象工厂模式</li>
                <img src="./img/AbstractFactory.jpg" height="501" width="660" alt="">
                <p>为创建一组相关或相互依赖的对象提供一个接口，而且无需指定它们的具体类。</p>
                <p>缺点：无法创建，新的产品类</p>
        </ul>
    <li>单例模式</li>
        <p>一个类至始至终都只产生一个实例化对象</p>
        <img src="img/Singleton.jpg" height="273" width="550" alt="">
        <ul>使用场景:
            <li>配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源</li>
            <li>应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加</li>
            <li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗</li>
        </ul>
    <li>原型模式</li>
        <p>使用clone生成对象</p>
        <p>应用场景： 类的资源非常多、性能和安全要求，一般和工厂方法结合使用</p>
    <li>建造者模式</li>
        <img src="img/Builder.jpg" height="338" width="713" alt="">
        <p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>
            建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式</p>
        <p>应用场景： 对象创建时需要进行很多工作时，如果创建一张二维码，需要设置高度，宽度，前景色，背景色。。。需要设置很多的属性，这时就可以采用建造者模式</p>
</ol>
二、结构型
    <ol>
        <li>适配器模式</li>
            <p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式</p>
            <img src="./img/Adapter.jpg" height="313" width="724" alt="">
            <ul>应用场景：
                <li>系统需要使用现有的类，而这些类的接口不符合系统的需要。 </li>
                <li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li>
            </ul>
        <li>装饰模式</li>
            <ul>
                一般有两种方式可以实现给一个类或对象增加行为：
                <li>继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</li>
                <li>关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)</li>
                <li>装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。这就是装饰模式的模式动机。</li>
            </ul>
            <img src="./img/Decorator.jpg" height="546" width="643" alt="">
            <ul>
                应用场景：
                <li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li>
                <li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。</li>
                <li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）</li>
            </ul>
        <li>代理模式</li>
        <li>组合模式</li>
    </ol>


